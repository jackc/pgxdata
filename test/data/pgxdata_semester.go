package data

// This file is automatically generated by pgxdata.

import (
	"context"
	"strings"

	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

type Semester struct {
	Year        pgtype.Int2
	Season      pgtype.Varchar
	Description pgtype.Text
}

const countSemesterSQL = `select count(*) from "semester"`

func CountSemester(ctx context.Context, db Queryer) (int64, error) {
	var n int64
	err := prepareQueryRow(ctx, db, "pgxdataCountSemester", countSemesterSQL).Scan(&n)
	return n, err
}

const SelectAllSemesterSQL = `select
  "year",
  "season",
  "description"
from "semester"`

func SelectAllSemester(ctx context.Context, db Queryer) ([]Semester, error) {
	var rows []Semester

	dbRows, err := prepareQuery(ctx, db, "pgxdataSelectAllSemester", SelectAllSemesterSQL)
	if err != nil {
		return nil, err
	}

	for dbRows.Next() {
		var row Semester
		dbRows.Scan(
			&row.Year,
			&row.Season,
			&row.Description,
		)
		rows = append(rows, row)
	}

	if dbRows.Err() != nil {
		return nil, dbRows.Err()
	}

	return rows, nil
}

const selectSemesterByPKSQL = `select
  "year",
  "season",
  "description"
from "semester"
where "year"=$1 and "season"=$2`

func SelectSemesterByPK(
	ctx context.Context,
	db Queryer,
	year int16,
	season string,
) (*Semester, error) {
	var row Semester
	err := prepareQueryRow(ctx, db, "pgxdataSelectSemesterByPK", selectSemesterByPKSQL, year, season).Scan(
		&row.Year,
		&row.Season,
		&row.Description,
	)
	if err == pgx.ErrNoRows {
		return nil, ErrNotFound
	} else if err != nil {
		return nil, err
	}

	return &row, nil
}

func InsertSemester(ctx context.Context, db Queryer, row *Semester) error {
	args := pgx.QueryArgs(make([]interface{}, 0, 3))

	var columns, values []string

	if row.Year.Status != pgtype.Undefined {
		columns = append(columns, `year`)
		values = append(values, args.Append(&row.Year))
	}
	if row.Season.Status != pgtype.Undefined {
		columns = append(columns, `season`)
		values = append(values, args.Append(&row.Season))
	}
	if row.Description.Status != pgtype.Undefined {
		columns = append(columns, `description`)
		values = append(values, args.Append(&row.Description))
	}

	sql := `insert into "semester"(` + strings.Join(columns, ", ") + `)
values(` + strings.Join(values, ",") + `)
returning "year", "season"
  `

	psName := preparedName("pgxdataInsertSemester", sql)

	return prepareQueryRow(ctx, db, psName, sql, args...).Scan(&row.Year, &row.Season)
}

func UpdateSemester(ctx context.Context, db Queryer,
	year int16,
	season string,
	row *Semester,
) error {
	sets := make([]string, 0, 3)
	args := pgx.QueryArgs(make([]interface{}, 0, 3))

	if row.Year.Status != pgtype.Undefined {
		sets = append(sets, `year`+"="+args.Append(&row.Year))
	}
	if row.Season.Status != pgtype.Undefined {
		sets = append(sets, `season`+"="+args.Append(&row.Season))
	}
	if row.Description.Status != pgtype.Undefined {
		sets = append(sets, `description`+"="+args.Append(&row.Description))
	}

	if len(sets) == 0 {
		return nil
	}

	sql := `update "semester" set ` + strings.Join(sets, ", ") + ` where ` + `"year"=` + args.Append(year) + ` and "season"=` + args.Append(season)

	psName := preparedName("pgxdataUpdateSemester", sql)

	commandTag, err := prepareExec(ctx, db, psName, sql, args...)
	if err != nil {
		return err
	}
	if commandTag.RowsAffected() != 1 {
		return ErrNotFound
	}
	return nil
}

func DeleteSemester(ctx context.Context, db Queryer,
	year int16,
	season string,
) error {
	args := pgx.QueryArgs(make([]interface{}, 0, 2))

	sql := `delete from "semester" where ` + `"year"=` + args.Append(year) + ` and "season"=` + args.Append(season)

	commandTag, err := prepareExec(ctx, db, "pgxdataDeleteSemester", sql, args...)
	if err != nil {
		return err
	}
	if commandTag.RowsAffected() != 1 {
		return ErrNotFound
	}
	return nil
}
